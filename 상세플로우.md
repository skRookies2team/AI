# 전체 시스템 아키텍처

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Frontend   │ ──▶ │   Backend   │ ──▶ │  AI Server  │
│  (React)    │ ◀── │  (Spring)   │ ◀── │  (FastAPI)  │
└─────────────┘     └─────────────┘     └─────────────┘
                          │
                          ▼
                    ┌─────────────┐
                    │   MariaDB   │
                    └─────────────┘
```

---

## AI 서버 API 엔드포인트

| 엔드포인트 | 메서드 | 설명 |
|------------|--------|------|
| `/` | GET | 상태 확인 |
| `/analyze` | POST | 소설 분석 → 게이지 제안 |
| `/analyze/file` | POST | txt 파일 업로드 → 게이지 제안 |
| `/generate` | POST | 스토리 생성 |
| `/generate/file` | POST | txt 파일로 스토리 생성 |

---

## API 요청/응답 형식

### POST /analyze
```json
// Request
{
  "novel_text": "소설 전체 텍스트..."
}

// Response
{
  "summary": "소설 요약 (500자)",
  "characters": [...],
  "gauges": [
    {
      "id": "hope",
      "name": "희망",
      "meaning": "...",
      "min_label": "절망",
      "max_label": "희망",
      "description": "...",
      "initial_value": 65
    }
  ]
}
```

### POST /generate
```json
// Request
{
  "novel_text": "소설 텍스트",
  "selected_gauge_ids": ["hope", "trust"],
  "num_episodes": 3,
  "max_depth": 3,
  "ending_config": {
    "happy": 2,
    "tragic": 1,
    "neutral": 1,
    "open": 1,
    "bad": 0,
    "bittersweet": 0
  },
  "num_episode_endings": 3
}

// Response
{
  "metadata": {...},
  "context": {...},
  "episodes": [...]
}
```

---

## 상세 파이프라인 (7단계)

### 1단계: 소설 요약 생성 (`_generate_summary`)

```
입력: 원본 소설 텍스트
      ↓
┌─────────────────────────────────────┐
│ 텍스트 길이 체크                      │
│  ├─ ≤ 20,000자: 직접 요약            │
│  └─ > 20,000자: 청크 분할 요약        │
│       ├─ 20,000자씩 분할             │
│       ├─ 각 청크 200자 요약          │
│       └─ 통합하여 500자 최종 요약     │
└─────────────────────────────────────┘
      ↓
출력: novel_summary (500자 내외)
```

**LLM 프롬프트 요청사항:**
- 핵심 줄거리
- 주제
- 갈등 구조
- 결말

---

### 2단계: 등장인물 추출 (`extract_characters`)

```
입력: 소설 텍스트 (줄번호 부착)
      ↓
┌─────────────────────────────────────┐
│ 텍스트 샘플링 (1000줄 초과 시)        │
│  ├─ 앞 400줄                        │
│  ├─ 중간 200줄                      │
│  └─ 뒤 400줄                        │
└─────────────────────────────────────┘
      ↓
LLM 분석
      ↓
출력: Character[]
```

**Character 구조:**
```json
{
  "name": "랠프",
  "aliases": ["금발의 소년", "대장"],
  "description": "금발의 소년으로 [cite: 8, 35], 만 12살입니다...",
  "relationships": [
    "잭과 리더십 문제로 대립함 [cite: 612, 892]"
  ]
}
```

---

### 3단계: 게이지 시스템 설계 (`suggest_gauges`)

```
입력: novel_summary
      ↓
LLM이 소설 테마/갈등 분석
      ↓
출력: Gauge[] (5개 제안)
      ↓
사용자가 2개 선택 (selected_gauge_ids)
```

**Gauge 구조:**
```json
{
  "id": "civilization",
  "name": "문명도",
  "meaning": "사회 질서와 규범을 유지하려는 정도",
  "min_label": "야만",
  "max_label": "질서",
  "description": "높을수록 민주적 리더십...",
  "initial_value": 65
}
```

**게이지 초기값:** AI가 소설 상황에 맞게 설정 (0~100)
- 평화로운 시작: hope = 70
- 위기 상황 시작: hope = 30

---

### 4단계: 최종 엔딩 설계 (`design_final_endings`)

```
입력: novel_summary + selected_gauges[] + ending_config
      ↓
LLM이 타입별 개수에 맞춰 엔딩 설계
      ↓
출력: FinalEnding[]
```

**ending_config (엔딩 타입별 개수 설정):**
```json
{
  "happy": 2,       // 행복한 엔딩 (희망적인 결말, 목표 달성)
  "tragic": 1,      // 비극적인 엔딩 (파멸, 죽음, 실패)
  "neutral": 1,     // 중립적인 엔딩 (무난한 결말)
  "open": 1,        // 열린 결말 (해석의 여지)
  "bad": 0,         // 나쁜 엔딩 (불행한 결말)
  "bittersweet": 0  // 씁쓸한 엔딩 (희생을 통한 성공)
}
```

**FinalEnding 구조:**
```json
{
  "id": "ending_hope",
  "type": "happy",
  "title": "구조의 희망",
  "condition": "hope >= 70 AND trust >= 60",
  "summary": "소년들은 끝까지 희망을 잃지 않고..."
}
```

**최종 엔딩 결정 방식:**
- 모든 에피소드 완료 후 누적된 게이지 값으로 condition 평가
- 조건에 맞는 엔딩으로 분기

---

### 5단계: 에피소드 분할 (`split_into_episodes`)

```
입력: novel_summary + characters[] + num_episodes
      ↓
LLM이 소설을 독립적 에피소드로 분할
      ↓
출력: episode_templates[]
```

**Episode Template 구조:**
```json
{
  "id": "ep1_encounter",
  "title": "첫 만남",
  "order": 1,
  "description": "주인공들이 처음 만나 서로를 알아가는 과정",
  "theme": "신뢰 형성",
  "key_characters": ["랠프", "잭", "피기"]
}
```

**중요 규칙:**
- 에피소드 간 스토리는 연결되지 않음 (독립적)
- 에피소드 간에는 **게이지만 누적**

---

### 6단계: 에피소드별 스토리 생성

각 에피소드마다 3개의 서브 단계 실행:

#### 6-1. 도입부 생성 (`generate_episode_intro`)

```
입력: episode_template + characters[] + novel_summary
      ↓
출력: intro_text (800~1200자)
```

**도입부 내용:**
- 현재 상황과 배경 설명
- 등장인물들의 대화와 행동
- 분위기와 감정 묘사
- 에피소드 핵심 갈등/테마 암시
- 자연스럽게 첫 선택지로 연결

---

#### 6-2. 스토리 트리 생성 (`generate_full_tree`)

**LangGraph StateGraph 사용:**

```
┌─────────────────────────────────────────────────────────┐
│                    StoryGenerationState                  │
│  ┌─────────────────────────────────────────────────┐    │
│  │ nodes: StoryNode[]        (생성된 노드 누적)      │    │
│  │ context: Dict             (캐릭터, 게이지, 엔딩)  │    │
│  │ max_depth: int            (최대 깊이)            │    │
│  │ current_gauges: Dict      (현재 게이지 상태)     │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

**트리 생성 흐름:**

```
                    [depth 0: 루트]
                    (first_choice)
                    선택지 2~4개
                   /      |      \
            [depth 1]  [depth 1]  [depth 1]
           (development)
            선택지 2~4개
           /    \
    [depth 2]  [depth 2]
    (climax)
    선택지 2~4개
       |
  [depth 3: max_depth]
    (ending)
    선택지 없음
```

**노드 타입:**
- `first_choice`: depth 0 (시작)
- `development`: 중간 depth
- `climax`: max_depth - 1
- `ending`: max_depth (선택지 없음)

**선택지 개수:** AI가 상황에 맞게 2~4개 자동 결정
- 단순한 상황, 긴박한 순간: 2개
- 일반적인 상황: 3개
- 중요한 분기점, 다양한 접근: 4개

**StoryNode 구조:**
```json
{
  "id": "a1b2c3d4",
  "depth": 1,
  "text": "스토리 본문 (500-800자)...",
  "details": {
    "npc_emotions": {"랠프": "불안", "잭": "흥분"},
    "situation": "현재 상황 한 줄 요약",
    "relations_update": {"랠프-잭": "적대감 상승"}
  },
  "choices": [
    {
      "text": "잭에게 협력을 제안한다",
      "tags": ["cooperative", "trusting"]
    },
    {
      "text": "혼자 행동하기로 결심한다",
      "tags": ["cautious", "doubtful"]
    }
  ],
  "parent_id": "root123",
  "node_type": "development",
  "episode_id": "ep1_encounter"
}
```

**선택지 태그 종류:**
| 태그 | 설명 |
|------|------|
| cooperative | 협력적 |
| aggressive | 공격적 |
| cautious | 신중한 |
| trusting | 신뢰하는 |
| doubtful | 의심하는 |
| brave | 용감한 |
| fearful | 두려워하는 |
| rational | 이성적 |
| emotional | 감정적 |

**Map-Reduce 패턴:**
```
[노드 생성] ──▶ [분기 판단] ──▶ [자식 노드들 병렬 생성]
     │              │                    │
     │              │                    ▼
     │              │         ┌───┬───┬───┐
     │              │         │   │   │   │
     │              └─────────▶ Send() Send() Send()
     │                              │
     └──────────────────────────────┘
               (반복)
```

---

#### 6-3. 에피소드 엔딩 설계 (`design_episode_endings`)

```
입력: episode_template + selected_gauges[] + num_episode_endings
      ↓
LLM이 엔딩 설계
      ↓
출력: EpisodeEnding[]
```

**EpisodeEnding 구조:**
```json
{
  "id": "ep1_ending_trust",
  "title": "신뢰의 시작",
  "condition": "cooperative >= 2 AND trusting >= 1",
  "text": "서로를 알아가며 신뢰가 싹텄다...",
  "gauge_changes": {
    "hope": 15,
    "trust": 20
  }
}
```

**게이지 변화량:** AI가 엔딩 중요도에 따라 유동적으로 설정
- 작은 영향: -10 ~ +10
- 보통 영향: -20 ~ +20
- 큰 영향 (극적인 엔딩): -30 ~ +30

**에피소드 엔딩 결정 방식:**
1. 플레이어가 선택한 선택지들의 **태그 누적**
2. 에피소드 끝에서 **condition** 평가
3. 조건에 맞는 엔딩 표시
4. **gauge_changes**로 게이지 변화 적용

---

### 7단계: 결과 저장 (`save_episode_story`)

**최종 출력 JSON 구조:**

```json
{
  "metadata": {
    "total_episodes": 3,
    "total_nodes": 45,
    "gauges": ["희망", "신뢰"],
    "character_count": 5
  },
  "context": {
    "novel_summary": "소설 요약...",
    "characters": [...],
    "gauges": [...],
    "final_endings": [...]
  },
  "episodes": [
    {
      "id": "ep1_encounter",
      "title": "첫 만남",
      "order": 1,
      "description": "...",
      "theme": "신뢰 형성",
      "intro_text": "도입부 텍스트 (800~1200자)...",
      "nodes": [
        {
          "id": "...",
          "depth": 0,
          "text": "...",
          "details": {...},
          "choices": [...],
          "parent_id": null,
          "node_type": "first_choice",
          "episode_id": "ep1_encounter"
        }
      ],
      "endings": [
        {
          "id": "ep1_ending_trust",
          "title": "신뢰의 시작",
          "condition": "cooperative >= 2",
          "text": "...",
          "gauge_changes": {"hope": 15, "trust": 20}
        }
      ]
    }
  ]
}
```

---

## 게이지 시스템 동작 요약

```
[게임 시작]
    │
    ▼
게이지 초기값 = AI가 설정한 initial_value
    │
    ▼
┌─────────────────────────────────┐
│        에피소드 1 플레이          │
│  ┌─────────────────────────┐    │
│  │ 선택지 선택 → 태그 누적    │    │
│  │ (cooperative +1 등)     │    │
│  └─────────────────────────┘    │
│              ↓                  │
│  ┌─────────────────────────┐    │
│  │ 에피소드 엔딩 결정         │    │
│  │ (태그 조건 평가)          │    │
│  └─────────────────────────┘    │
│              ↓                  │
│  ┌─────────────────────────┐    │
│  │ gauge_changes 적용       │    │
│  │ (AI가 설정한 변화량)      │    │
│  └─────────────────────────┘    │
└─────────────────────────────────┘
    │
    ▼
에피소드 2, 3... 반복
    │
    ▼
┌─────────────────────────────────┐
│     최종 게이지 값으로            │
│     FinalEnding 결정            │
│  (hope >= 70 AND trust >= 60)  │
└─────────────────────────────────┘
```

---

## 웹 연동 흐름

```
[프론트엔드]                    [백엔드]                     [AI 서버]
     │                            │                            │
     │  1. txt 파일 업로드          │                            │
     │ ─────────────────────────▶ │                            │
     │                            │  2. POST /analyze           │
     │                            │ ─────────────────────────▶ │
     │                            │                            │
     │                            │  3. 게이지 리스트 반환       │
     │                            │ ◀───────────────────────── │
     │  4. 게이지 선택 UI 표시      │                            │
     │ ◀───────────────────────── │                            │
     │                            │                            │
     │  5. 설정 선택               │                            │
     │     - 게이지 2개            │                            │
     │     - 에피소드 개수          │                            │
     │     - 트리 깊이             │                            │
     │     - 엔딩 타입별 개수       │                            │
     │ ─────────────────────────▶ │                            │
     │                            │  6. POST /generate          │
     │                            │     (ending_config 포함)    │
     │                            │ ─────────────────────────▶ │
     │                            │                            │
     │                            │      (스토리 생성 중...)     │
     │                            │      (수 분 소요)           │
     │                            │                            │
     │                            │  7. 스토리 JSON 반환        │
     │                            │ ◀───────────────────────── │
     │                            │                            │
     │                            │  8. DB 저장                 │
     │                            │                            │
     │  9. 결과 반환               │                            │
     │ ◀───────────────────────── │                            │
```

---

## 역할 분담

### AI 서버 (이 프로젝트)
- 소설 분석 (요약, 캐릭터, 게이지 제안)
- 스토리 생성 (노드, 선택지, 엔딩)
- ending_config에 따른 엔딩 타입별 생성

### 백엔드 (Spring Boot)
- 프론트엔드와 통신
- AI 서버 호출
- DB 저장/조회
- 엔딩 타입 목록 제공 (UI용)
- 게임 플레이 로직 (선택지 처리, 태그 누적, 게이지 계산)
- 사용자 세션 관리

### 프론트엔드
- 파일 업로드 UI
- 게이지 선택 UI
- 엔딩 타입별 개수 선택 UI
- 게임 플레이 UI

---

## 예상 노드 수

| 깊이 (max_depth) | 예상 노드 수 | 설명 |
|------------------|-------------|------|
| 2 | ~7개 | 간단한 스토리 |
| 3 | ~15-40개 | 보통 스토리 |
| 4 | ~40-120개 | 복잡한 스토리 |
| 5 | ~100-300개 | 매우 복잡 |

※ 선택지 개수(2~4개)에 따라 기하급수적으로 증가
